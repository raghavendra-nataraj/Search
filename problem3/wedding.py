#!/usr/bin/env python
# -*- coding: utf-8 -*-

''' Abstraction for problem 3:
a. Valid States, S = Any arrangement of X people on Y or less than Y number of tables
d. Goal state, G = {S | S belongs to the set of valid states where X people are assigned to minimum number of tables Y such that each person is assigned to exactly one table and that each person on the table knows no other person on the same table}
c. Initial state, S0 = phi = Single table with no people assigned to that table
d. Successor function, Succ(S) = {S’ | S’ is list of states generated by adding a new person to one of the existing tables or to a new table}
e. Cost Function = The cost function would not change since the goal is to arrange X number people on minimum number of tables, i.e., Y such that each person on the table knows no other person on the same table. The cost function keeps increasing with each person added to the table until the goal state is reached. Thus, we can say that the cost is constant.

Algorityhm used:
Each person is added to already available table provided the added person does not conflict with the condition(does not have a friend in the table). Also he is added to a new table. So we create all possible combinations and keep removing successors when we face conflicts. Thus we will achieve multiple goals out of which we pick the least number of table
'''

import sys
from sets import Set
from copy import deepcopy
friends = {}
fringe = []
people = Set()
peopleCpy = Set()
minResult = sys.maxint
class State():
    def __init__(self,st,pl):
        self.st = st
        self.pl = pl

def parseFile():
    global peopleCpy
    global friends
    ifile = open(sys.argv[1],"r")
    content = ifile.readlines()
    for line in content:
        lst = line[:len(line)-1].split(" ")
        people.update(lst)
        if lst[0] not in friends:
            friends[lst[0]] = Set(lst[1:])
        else:
            friends[lst[0]].update(lst[1:])
        for friend in friends[lst[0]]:
            if friend in friends:
                friends[friend].add(lst[0])
            else:
                friends[friend] = Set([lst[0]])
    peopleCpy = deepcopy(people)

def addPerson(state,table,person):
    state.st[state.st.index(table)].append(person)
    return state.st

def isValid(table,person):
    return len(Set(friends[person]).intersection(Set(table)))<1

def successors(state):
    if len(state.pl)>0:
        person = state.pl.pop()
        st =  [State(addPerson(deepcopy(state),table,person),deepcopy(state.pl)) for table in state.st if len(table)<int(sys.argv[2]) and isValid(table,person) and len(state.st)<=minResult]
        state.st.append([person])
        st.append(state)
        return st
    return []

def isGoal(state):
    isTrue = True
    if len(peopleCpy)==sum([len(s) for s in state.st]):
        return all([len(Set(friends[friend]).intersection(Set(table)))<1 \
                   for table in state.st for friend in table])
    else:
        isTrue = False
    return isTrue
            

def solve(state):
    global minResult,goal
    fringe.append(state)
    while len(fringe)>0:
        for st in successors(fringe.pop()):
            if isGoal(st):
                if len(st.st)<minResult:
                    goal = st.st
                    minResult = len(st.st)
            fringe.append(st)
        

parseFile()
initialState = []
state = State(initialState,people)
solve(state)

print len(goal),
for idx in goal:
    for person in idx:
        print person,
    print ",",
